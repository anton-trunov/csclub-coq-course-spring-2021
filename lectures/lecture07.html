<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" class="alectryon-standalone" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>Views. reflect-predicate. Multi-rewrite rules</title>
<meta name="author" content="Anton Trunov" />
<meta name="date" content="April 22, 2021" />
<link rel="stylesheet" href="alectryon.css" type="text/css" />
<link rel="stylesheet" href="docutils_basic.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.css" type="text/css" />
<link rel="stylesheet" href="tango_subtle.min.css" type="text/css" />
<script type="text/javascript" src="alectryon.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/IBM-type/0.5.4/css/ibm-type.min.css" integrity="sha512-sky5cf9Ts6FY1kstGOBHSybfKqdHR41M0Ldb0BjNiv3ifltoQIsg0zIaQ+wwdwgQ0w9vKFW7Js50lxH9vqNSSw==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/firacode/5.2.0/fira_code.min.css" integrity="sha512-MbysAYimH1hH2xYzkkMHB6MqxBqfP0megxsCLknbYqHVwXTCg9IqHbk+ZP/vnhO8UEW6PaXAkKe2vQ+SWACxxA==" crossorigin="anonymous" />
<meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
<div class="alectryon-root alectryon-centered"><div class="alectryon-banner">Built with <a href="https://github.com/cpitclaudel/alectryon/">Alectryon</a>, running Coq+SerAPI v8.13.0+0.13.0. Bubbles (<span class="alectryon-bubble"></span>) indicate interactive fragments: hover for details, tap to reveal contents. Use <kbd>Ctrl+‚Üë</kbd> <kbd>Ctrl+‚Üì</kbd> to navigate, <kbd>Ctrl+üñ±Ô∏è</kbd> to focus. On Mac, use <kbd>‚åò</kbd> instead of <kbd>Ctrl</kbd>.</div><div class="document" id="views-reflect-predicate-multi-rewrite-rules">
<h1 class="title">Views. <code class="highlight coq"><span class="name">reflect</span></code>-predicate. Multi-rewrite rules</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Anton Trunov</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>April 22, 2021</td></tr>
</tbody>
</table>
<input type="checkbox" class="alectryon-toggle" id="alectryon-toggle-0" /><label for="alectryon-toggle-0" class="alectryon-toggle-label">Display all goals and responses</label><div class="alectryon-container docutils container">
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk0" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk0"><span class="highlight"><span class="kn">From</span> mathcomp <span class="kn">Require Import</span> ssreflect ssrfun ssrbool eqtype ssrnat seq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ | _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ : _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ | _ ]&quot;</span> was already used
<span class="kr">in</span> scope fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ &amp; _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ | _ ]&quot;</span> was already used <span class="kr">in</span>
scope fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ rel _ _ in _ ]&quot;</span> was already used <span class="kr">in</span> scope
fun_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ + _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ - _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt;= _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &gt; _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt;= _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt;= _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ &lt; _ &lt; _&quot;</span> was already used <span class="kr">in</span> scope
nat_scope. [notation-overridden,parsing]</span></blockquote><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;_ * _&quot;</span> was already used <span class="kr">in</span> scope nat_scope.
[notation-overridden,parsing]</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Set Implicit Arguments</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Unset Strict Implicit</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Unset Printing Implicit Defensive</span>.</span></span></span></pre><hr class="docutils" />
<div class="section" id="reflect-predicate">
<h1><code class="highlight coq"><span class="name">reflect</span></code>-predicate</h1>
<p>As we mentioned earlier, the SSReflect proof
methodology is based on having logical and
symbolic (e.g. boolean) representations intermixed
in a goal, so that the user can switch between
those to drive the proof process.</p>
<p>The SSReflect methodology, thus, favors computable
predicates and relations.</p>
<p>Let's see an example now.</p>
<div class="section" id="motivational-example">
<h2>Motivational example</h2>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk1" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk1"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">all_filter</span> <span class="nv">T</span> (<span class="nv">p</span> : pred T) (<span class="nv">s</span> : seq T) :
  <span class="kp">all</span> p s -&gt; filter p s = s.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kp">all</span> p s -&gt; [seq x &lt;- s | p x] = s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk2" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kp">all</span> p s -&gt; [seq x &lt;- s | p x] = s</span></div></blockquote></div></div></small></span></pre><p>First of all, let's try and understand the
goal we see here. There are several things:</p>
<ul class="simple">
<li><code class="highlight coq"><span class="name">p</span> <span class="operator">:</span> <span class="name">pred</span> <span class="name">T</span></code> means <code class="highlight coq"><span class="name">p</span></code> is a <em>computable</em> predicate
over type <code class="highlight coq"><span class="name">T</span></code>, i.e. <code class="highlight coq"><span class="name">pred</span> <span class="name">T</span></code> is <code class="highlight coq"><span class="name">T</span> <span class="operator">-&gt;</span> <span class="name">bool</span></code>;</li>
<li><code class="highlight coq"><span class="keyword pseudo">all</span> <span class="name">p</span> <span class="name">s</span></code> means all elements of sequence <code class="highlight coq"><span class="name">s</span></code>
satisfy predicate <code class="highlight coq"><span class="name">p</span></code>;</li>
<li><code class="highlight coq"><span class="operator">[</span><span class="name">seq</span> <span class="name">x</span> <span class="operator">&lt;-</span> <span class="name">s</span> <span class="operator">|</span> <span class="name">p</span> <span class="name">x</span><span class="operator">]</span></code> notation stands for
<code class="highlight coq"><span class="name">filter</span> <span class="operator">(</span><span class="keyword reserved">fun</span> <span class="name variable">x</span> <span class="operator">=&gt;</span> <span class="name">p</span> <span class="name">x</span><span class="operator">)</span> <span class="name">s</span></code>.</li>
</ul>
<p>We can check all the above bullet points with
the following three simple commands:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="lecture07-v-chk3" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk3"><span class="highlight"><span class="kn">Print</span> pred.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">pred = <span class="kr">fun</span> <span class="nv">T</span> : <span class="kt">Type</span> =&gt; T -&gt; bool
     : <span class="kt">Type</span> -&gt; <span class="kt">Type</span>

<span class="kn">Arguments</span> pred _%type_scope</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="lecture07-v-chk4" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk4"><span class="highlight"><span class="kn">Check</span> <span class="kp">all</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kp">all</span>
     : pred <span class="nl">?T</span> -&gt; seq <span class="nl">?T</span> -&gt; bool
<span class="kn">where</span>
<span class="nl">?T</span> : [T : <span class="kt">Type</span>  p : pred T  s : seq T |- <span class="kt">Type</span>]</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="lecture07-v-chk5" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk5"><span class="highlight"><span class="kn">Locate</span> <span class="s2">&quot;[ seq _ &lt;- _ | _ ]&quot;</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;[ &#39;seq&#39; x &lt;- s | C ]&quot;</span> :=
  (filter (<span class="kr">fun</span> <span class="nv">x</span> =&gt; C) s) : seq_scope
  (default interpretation)</span></blockquote></div></div></small></span></pre><p>But wait a minute, how come we can have a term
of type <code class="highlight coq"><span class="name">bool</span></code> as an assumption in our goal?</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk6" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk6"><span class="highlight"><span class="kn">Check</span> <span class="kp">all</span> p s : bool.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kp">all</span> p s : bool
     : bool</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kp">all</span> p s -&gt; [seq x &lt;- s | p x] = s</span></div></blockquote></div></div></small></span></pre><p>And why the following works at all?</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk7" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk7"><span class="highlight"><span class="kn">Check</span> <span class="kp">all</span> p s : <span class="kt">Type</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kp">all</span> p s : <span class="kt">Type</span>
     : <span class="kt">Type</span></span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kp">all</span> p s -&gt; [seq x &lt;- s | p x] = s</span></div></blockquote></div></div></small></span></pre><p>This works because of the mechanism of
<em>implicit coercions</em> Coq uses to make sense of
goals like the current one. To see clearly what is
going on here, use the following vernacular:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk8" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk8"><span class="highlight"><span class="kn">Set Printing Coercions</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">is_true (<span class="kp">all</span> p s) -&gt; [seq x &lt;- s | p x] = s</span></div></blockquote></div></div></small></span></pre><p>Now we can see Coq inserted the corcion
<code class="highlight coq"><span class="name">is_true</span></code> around <code class="highlight coq"><span class="keyword pseudo">all</span> <span class="name">p</span> <span class="name">s</span></code> so the goal would
actually make sense.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="lecture07-v-chk9" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk9"><span class="highlight"><span class="kn">Print</span> is_true.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">is_true = eq^~ true
     : bool -&gt; <span class="kt">Prop</span>

<span class="kn">Arguments</span> is_true _%bool_scope
is_true <span class="kr">is</span> a coercion</span></blockquote></div></div></small></span></pre><p>If <code class="highlight coq"><span class="name">eq</span><span class="operator">^~</span> <span class="name">true</span></code> does not really make sense for
you:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="lecture07-v-chka" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chka"><span class="highlight"><span class="kn">Locate</span> <span class="s2">&quot;^~&quot;</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="s2">&quot;f ^~ y&quot;</span> := (<span class="kr">fun</span> <span class="nv">x</span> =&gt; f x y) : fun_scope
  (default interpretation)</span></blockquote></div></div></small></span></pre><p>Another approach would be to unfold <code class="highlight coq"><span class="name">is_true</span></code>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkb" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkb"><span class="highlight"><span class="nb">rewrite</span> /is_true.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kp">all</span> p s = true -&gt; [seq x &lt;- s | p x] = s</span></div></blockquote></div></div></small></span></pre><p>Given the above, <code class="highlight coq"><span class="name">is_true</span> <span class="name">b</span></code> means <code class="highlight coq"><span class="name">b</span> <span class="operator">=</span> <span class="name">true</span></code>
-- this is one way to embed booleans into <code class="highlight coq"><span class="keyword type">Prop</span></code>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc"><span class="highlight"><span class="kn">Unset Printing Coercions</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kp">all</span> p s = true -&gt; [seq x &lt;- s | p x] = s</span></div></blockquote></div></div></small></span></pre><p>Now that we understand the goal we can prove
it by induction on <code class="highlight coq"><span class="name">s</span></code>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkd" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkd"><span class="highlight"><span class="nb">elim</span>: s =&gt; //= x s IHs.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">all</span> p s = true -&gt; [seq x &lt;- s | p x] = s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">p x &amp;&amp; <span class="kp">all</span> p s = true -&gt;
(<span class="kr">if</span> p x
 <span class="kr">then</span> x :: [seq x &lt;- s | p x]
 <span class="kr">else</span> [seq x &lt;- s | p x]) = x :: s</span></div></blockquote></div></div></small></span></pre><p>In our top assumption we have both <code class="highlight coq"><span class="name">p</span> <span class="name">x</span></code> which
is needed to simplify the <code class="highlight coq"><span class="keyword reserved">if</span></code>-expression in the
goal conclusion and <code class="highlight coq"><span class="keyword pseudo">all</span> <span class="name">p</span> <span class="name">s</span></code> which is needed to
apply the induction hypothesis. So, at this point
we need to transform an assumption from its
symbolic form <code class="highlight coq"><span class="name label">?x</span> <span class="operator">&amp;&amp;</span> <span class="name label">?y</span> <span class="operator">=</span> <span class="name">true</span></code> into its logical
form <code class="highlight coq"><span class="name label">?x</span> <span class="operator">=</span> <span class="name">true</span> <span class="operator">/\</span> <span class="name label">?y</span> <span class="operator">=</span> <span class="name">true</span></code>.</p>
<p>To do this we are going to use the mechanism of
<em>views</em> supported by SSReflect.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chke" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chke"><span class="highlight"><span class="nb">move</span>=&gt; /andP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">all</span> p s = true -&gt; [seq x &lt;- s | p x] = s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">p x /\ <span class="kp">all</span> p s -&gt;
(<span class="kr">if</span> p x
 <span class="kr">then</span> x :: [seq x &lt;- s | p x]
 <span class="kr">else</span> [seq x &lt;- s | p x]) = x :: s</span></div></blockquote></div></div></small></span></pre><p>We already know the <code class="highlight coq"><span class="operator">/</span><span class="name">lemma</span></code> syntax as we saw
how it works for lemmas which are implications. In
this case it's something like this as well,
although there is some implicit machinery at work
too. The mechanism is called <em>view hints</em> and we
are going to cover it later. The rest of the proof
is very straightforward.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkf" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkf"><span class="highlight"><span class="nb">case</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">all</span> p s = true -&gt; [seq x &lt;- s | p x] = s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">p x -&gt;
<span class="kp">all</span> p s -&gt;
(<span class="kr">if</span> p x
 <span class="kr">then</span> x :: [seq x &lt;- s | p x]
 <span class="kr">else</span> [seq x &lt;- s | p x]) = x :: s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk10" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk10"><span class="highlight"><span class="nb">move</span>=&gt; -&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">all</span> p s = true -&gt; [seq x &lt;- s | p x] = s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kp">all</span> p s -&gt; x :: [seq x &lt;- s | p x] = x :: s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk11" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk11"><span class="highlight"><span class="nb">move</span>/IHs.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">all</span> p s = true -&gt; [seq x &lt;- s | p x] = s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">[seq x &lt;- s | p x] = s -&gt;
x :: [seq x &lt;- s | p x] = x :: s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk12" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk12"><span class="highlight"><span class="nb">move</span>=&gt;-&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">IHs</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kp">all</span> p s = true -&gt; [seq x &lt;- s | p x] = s</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x :: s = x :: s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">done</span>.</span></span></span></pre><p>Let us refactor the proof above into something
more idiomatic</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk13" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk13"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Type</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">p</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">pred T</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">s</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">seq T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kp">all</span> p s -&gt; [seq x &lt;- s | p x] = s</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">elim</span>: s=&gt; //= x s IHs /andP[-&gt; /IHs-&gt;].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div>
<div class="section" id="reflect-predicate-definition">
<h2><code class="highlight coq"><span class="name">reflect</span></code>-predicate: definition</h2>
<p>So, what is <code class="highlight coq"><span class="name">reflect</span></code> in the type of <code class="highlight coq"><span class="name">andP</span></code>
from above?</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="lecture07-v-chk14" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk14"><span class="highlight"><span class="kn">About</span> andP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">andP :
<span class="kr">forall</span> {<span class="nv">b1</span> <span class="nv">b2</span> : bool}, reflect (b1 /\ b2) (b1 &amp;&amp; b2)

andP <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> andP {b1 b2}%bool_scope
andP <span class="kr">is</span> opaque
Expands to: Constant Coq.ssr.ssrbool.andP</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="lecture07-v-chk15" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk15"><span class="highlight"><span class="kn">Print</span> reflect.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Notation</span> <span class="nf">reflect</span> := Bool.reflect</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input checked="checked" class="alectryon-toggle" id="lecture07-v-chk16" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk16"><span class="highlight"><span class="kn">Print</span> Bool.reflect.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight"><span class="kn">Inductive</span> <span class="nf">reflect</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) : bool -&gt; <span class="kt">Set</span> :=
    ReflectT : P -&gt; reflect P true
  | ReflectF : ~ P -&gt; reflect P false

<span class="kn">Arguments</span> Bool.reflect _%type_scope _%bool_scope
<span class="kn">Arguments</span> Bool.ReflectT _%type_scope _
<span class="kn">Arguments</span> Bool.ReflectF _%type_scope _</span></blockquote></div></div></small></span></pre><p>The <code class="highlight coq"><span class="name">reflect</span></code> type family (or indexed type, in
other words) connects a <em>decidable</em> proposition to
the corresponding boolean expression. This is not
the first time we come across an indexed type but
it's the first time we run into an indexed type
with two constructors where we can clearly see the
difference between <em>parameters</em> (which have to be
fixed across constructors, <code class="highlight coq"><span class="name">P</span></code> here is a
parameter) and <em>indices</em> (which can vary between
constructors). In this case, type-level boolean
term indicates which constructor has been used to
construct a term of type <code class="highlight coq"><span class="name">reflect</span> <span class="name">P</span> <span class="name">b</span></code>, e.g. when
one has a term of type <code class="highlight coq"><span class="name">reflect</span> <span class="name">P</span> <span class="name">true</span></code> they know
the <code class="highlight coq"><span class="name">ReflectT</span></code> constructor has been used to
construct the term which means we have a proof of
<code class="highlight coq"><span class="name">P</span></code> we can get by pattern-matching on a term of
type <code class="highlight coq"><span class="name">reflect</span> <span class="name">P</span> <span class="name">true</span></code>. (And pattern-matching on a
term of type <code class="highlight coq"><span class="name">reflect</span> <span class="name">P</span> <span class="name">false</span></code> yields a refutation
of <code class="highlight coq"><span class="name">P</span></code>.)</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk17" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk17"><span class="highlight"><span class="kn">Goal</span> <span class="kr">forall</span> <span class="nv">P</span>, reflect P true -&gt; P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, reflect P true -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk18" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk18"><span class="highlight"><span class="nb">move</span>=&gt; P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P true -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span>: (
  <span class="kr">fun</span> <span class="nv">r</span> : reflect P true =&gt;
    <span class="kr">match</span>
      r <span class="kr">in</span> reflect _ b
      <span class="kr">return</span> (b = true -&gt; P)
    <span class="kr">with</span>
    | ReflectT p =&gt; <span class="kr">fun</span> <span class="nv">E</span> =&gt; p
    | ReflectF np =&gt; <span class="kr">fun</span> <span class="nv">E</span> =&gt; <span class="kp">ltac</span>:(<span class="bp">done</span>)
    <span class="kr">end</span> erefl).</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk19" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk19"><span class="highlight"><span class="kn">Undo</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P true -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk1a" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk1a"><span class="highlight"><span class="nb">case</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk1b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk1b"><hr></label><div class="goal-conclusion"><span class="highlight">~ P -&gt; P</span></div></blockquote></div></div></div></small></span></pre><p><code class="highlight coq"><span class="name builtin">case</span></code> actually leads to unprovable goals
here. It's not intelligent enough to solve this
goal which requires <em>dependent</em> pattern matching.
We need to use a special version of <code class="highlight coq"><span class="name builtin">case</span></code> for
type families. Here is the syntax we need to solve
this.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk1c" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk1c"><span class="highlight"><span class="kn">Undo</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P true -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk1d" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk1d"><span class="highlight"><span class="nb">move</span>=&gt; R.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">R</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">reflect P true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk1e" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk1e"><span class="highlight"><span class="nb">case</span> E: true / R.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">_p_</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true = true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk1f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">_n_</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true = false</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk1f"><hr></label><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></div></small></span></pre><p>To the right of <code class="highlight coq"><span class="operator">/</span></code> we put a term (<code class="highlight coq"><span class="name">R</span></code> in this
case) we are going to case analyse -- this needs
to be a type family. And to the left of <code class="highlight coq"><span class="operator">/</span></code> we put
the indices of the type family we'd like to get
substituted. Notice that we need to keep the
relation between the original value of the index
<code class="highlight coq"><span class="name">true</span></code> and its values inside the branches of the
underlying <code class="highlight coq"><span class="keyword reserved">match</span></code>-expression and this is what <code class="highlight coq"><span class="name">E</span></code>
in <code class="highlight coq"><span class="name builtin">case</span><span class="operator">:</span> <span class="name">E</span></code> is for.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk20" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk20"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">_p_</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true = true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk21" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">_n_</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true = false</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk21"><hr></label><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk22" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk22"><span class="highlight"><span class="bp">done</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">_n_</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ P</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">E</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true = false</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">done</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk23" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk23"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, reflect P true -&gt; P</span></div></blockquote></div></div></small></span></pre><p>Instead of <code class="highlight coq"><span class="name builtin">move</span><span class="operator">=&gt;</span> <span class="name">R</span><span class="operator">;</span> <span class="name builtin">case</span> <span class="name">E</span><span class="operator">:</span> <span class="name">true</span> <span class="operator">/</span> <span class="name">R</span></code> we can
use a shorhand:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">move</span>=&gt; P; <span class="nb">case</span> E: true /.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk24" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk24"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="kr">forall</span> <span class="nv">P</span> : <span class="kt">Prop</span>, reflect P true -&gt; P</span></div></blockquote></div></div></small></span></pre><p>Moreover, SSReflect can figure out the indices
on its own:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">move</span>=&gt; P; <span class="nb">case</span> E: _/.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>A lemma like <code class="highlight coq"><span class="name">reflect</span> <span class="name">P</span> <span class="name">false</span> <span class="operator">-&gt;</span> <span class="operator">~</span> <span class="name">P</span></code> can be
proved analogously.</p>
<p>To reinforce what has been said already, let
us formally prove several lemmas about <code class="highlight coq"><span class="name">reflect</span></code>.
For instance, we can show <code class="highlight coq"><span class="name">P</span></code> if and only if <code class="highlight coq"><span class="name">b</span> <span class="operator">=</span>
<span class="name">true</span></code> as two separate lemmas.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk25" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk25"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">introT_my</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool) :
  reflect P b -&gt; (P -&gt; b).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P b -&gt; P -&gt; b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk26" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk26"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P b -&gt; P -&gt; b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk27" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk27"><span class="highlight"><span class="nb">case</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; P -&gt; true</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk28" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk28"><hr></label><div class="goal-conclusion"><span class="highlight">~ P -&gt; P -&gt; false</span></div></blockquote></div></div></div></small></span></pre><p>The index <code class="highlight coq"><span class="name">b</span></code> here works as a rewrite rule.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk29" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk29"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">P -&gt; P -&gt; true</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk2a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk2a"><hr></label><div class="goal-conclusion"><span class="highlight">~ P -&gt; P -&gt; false</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk2b" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk2b"><span class="highlight"><span class="bp">done</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ P -&gt; P -&gt; false</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">move</span>=&gt; /[<span class="nb">apply</span>].</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>The other direction is left as an exercise for
the reader.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk2c" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk2c"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">elimT_my</span> (<span class="nv">P</span> : <span class="kt">Prop</span>) (<span class="nv">b</span> : bool) :
  reflect P b -&gt; (b -&gt; P).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P b -&gt; b -&gt; P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><p>Essentially, we have shown <code class="highlight coq"><span class="name">reflect</span> <span class="name">P</span> <span class="name">b</span> <span class="operator">-&gt;</span> <span class="operator">(</span><span class="name">b</span>
<span class="operator">&lt;-&gt;</span> <span class="name">P</span><span class="operator">)</span></code>, i.e. <code class="highlight coq"><span class="name">reflect</span> <span class="name">P</span> <span class="name">b</span></code> connects a decidable
proposition <code class="highlight coq"><span class="name">P</span></code> to its decision procedure (the
boolean expression <code class="highlight coq"><span class="name">b</span></code>).</p>
<p>For example, we can show <code class="highlight coq"><span class="name">reflect</span> <span class="name">P</span> <span class="name">b</span></code> lets us
use classical reasoning (exercise):</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk2d" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk2d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">reflect_lem</span> <span class="nv">P</span> <span class="nv">b</span> :
  reflect P b -&gt; P \/ ~ P.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">P</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight"><span class="kt">Prop</span></span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect P b -&gt; P \/ ~ P</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre><p>Lets look at how to build <code class="highlight coq"><span class="name">reflect</span></code>-predicates
for a couple of standard connectives.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk2e" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk2e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">andP_my</span> (<span class="nv">b</span> <span class="nv">c</span> : bool) :
  reflect (b /\ c) (b &amp;&amp; c).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (b /\ c) (b &amp;&amp; c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk2f" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk2f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (b /\ c) (b &amp;&amp; c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk30" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk30"><span class="highlight"><span class="nb">case</span>: b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (true /\ c) (true &amp;&amp; c)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk31" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk31"><hr></label><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk32" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk32"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (true /\ c) (true &amp;&amp; c)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk33" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk33"><hr></label><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk34" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk34"><span class="highlight"><span class="nb">case</span>: c.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (true /\ true) (true &amp;&amp; true)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk35" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (true /\ false) (true &amp;&amp; false)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk36" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk36"><hr></label><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk37" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk37"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (true /\ true) (true &amp;&amp; true)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk38" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (true /\ false) (true &amp;&amp; false)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk39" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk39"><hr></label><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk3a" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk3a"><span class="highlight"><span class="nb">constructor</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true /\ true</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk3b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (true /\ false) (true &amp;&amp; false)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk3c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk3c"><hr></label><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk3d" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk3d"><span class="highlight"><span class="bp">done</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (true /\ false) (true &amp;&amp; false)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk3e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk3e"><hr></label><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk3f" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk3f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (true /\ false) (true &amp;&amp; false)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk40" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk40"><hr></label><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk41" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk41"><span class="highlight"><span class="nb">constructor</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (true /\ false)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk42" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk42"><hr></label><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">    </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk43" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk43"><span class="highlight"><span class="bp">by</span> <span class="nb">case</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk44" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk44"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (false /\ c) (false &amp;&amp; c)</span></div></blockquote></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk45" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk45"><span class="highlight"><span class="nb">constructor</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (false /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk46" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk46"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (b /\ c) (b &amp;&amp; c)</span></div></blockquote></div></div></small></span></pre><p>An idiomatic solution would look something
like so:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">case</span>: b; <span class="nb">case</span>: c; <span class="nb">constructor</span>=&gt; //; <span class="nb">case</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk47" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk47"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">nandP_my</span> <span class="nv">b</span> <span class="nv">c</span> :
  reflect (~~ b \/ ~~ c) (~~ (b &amp;&amp; c)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (~~ b \/ ~~ c) (~~ (b &amp;&amp; c))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk48" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk48"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (~~ b \/ ~~ c) (~~ (b &amp;&amp; c))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk49" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk49"><span class="highlight"><span class="nb">case</span>: b; <span class="nb">case</span>: c; <span class="nb">constructor</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (~~ true \/ ~~ true)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk4a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ true \/ ~~ false</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk4b" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ true</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk4c" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ false</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk4d" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk4d"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (~~ true \/ ~~ true)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk4e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ true \/ ~~ false</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk4f" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ true</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk50" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ false</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk51" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk51"><span class="highlight"><span class="bp">by</span> <span class="nb">case</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ true \/ ~~ false</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk52" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ true</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk53" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ false</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk54" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk54"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ true \/ ~~ false</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk55" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ true</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk56" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ false</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk57" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk57"><span class="highlight"><span class="bp">by</span> <span class="nb">right</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ true</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk58" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ false</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk59" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk59"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ true</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk5a" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ false</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk5b" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk5b"><span class="highlight"><span class="bp">by</span> <span class="nb">left</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~~ false \/ ~~ false</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">left</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk5c" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk5c"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (~~ b \/ ~~ c) (~~ (b &amp;&amp; c))</span></div></blockquote></div></div></small></span></pre><p>This seems to be a rare opportunity for an
automatic tactic to fill in the blanks for us: the
<code class="highlight coq"><span class="name builtin">intuition</span></code> tactic can take care of the subgoals
generated by our brute force approach.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">case</span>: b; <span class="nb">case</span>: c; <span class="nb">constructor</span>; <span class="nb">intuition</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Sometimes we will need to use <code class="highlight coq"><span class="name">reflect</span> <span class="name">b</span> <span class="name">b</span></code> as
a placeholder. This is an easy exercise.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk5d" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk5d"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">idP_my</span> (<span class="nv">b</span> : bool) :
  reflect b b.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect b b</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Admitted</span>.</span></span></span></pre></div>
<div class="section" id="using-reflection-views-on-assumptions">
<h2>Using reflection views on assumptions</h2>
<p>Let's continue figuring out how and why <code class="highlight coq"><span class="name">andP</span></code>
works.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk5e" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk5e"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">special_support_for_reflect_predicates</span> <span class="nv">b</span> <span class="nv">c</span> :
  b &amp;&amp; c -&gt; b /\ c.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c -&gt; b /\ c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk5f" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk5f"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c -&gt; b /\ c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk60" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk60"><span class="highlight"><span class="nb">move</span>/andP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c -&gt; b /\ c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk61" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk61"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(<span class="kr">fun</span> (<span class="nv">b</span> <span class="nv">c</span> : bool) (<span class="nv">_view_subject_</span> : b &amp;&amp; c) =&gt;
 <span class="nl">?Goal</span> (elimTF andP _view_subject_))</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c -&gt; b /\ c</span></div></blockquote></div></div></small></span></pre><p>We see <code class="highlight coq"><span class="name">andP</span></code> in a context of <code class="highlight coq"><span class="name">elimTF</span></code>, let's
see what it is.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk62" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk62"><span class="highlight"><span class="kn">About</span> elimTF.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">elimTF :
<span class="kr">forall</span> [P : <span class="kt">Prop</span>] [b c : bool],
reflect P b -&gt; b = c -&gt; <span class="kr">if</span> c <span class="kr">then</span> P <span class="kr">else</span> ~ P

elimTF <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> elimTF [P]%type_scope [b c]%bool_scope _ _
elimTF <span class="kr">is</span> opaque
Expands to: Constant Coq.ssr.ssrbool.elimTF</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c -&gt; b /\ c</span></div></blockquote></div></div></small></span></pre><p><code class="highlight coq"><span class="name">elimTF</span></code> is a generalization of <code class="highlight coq"><span class="name">elimT</span></code> we proved above.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk63" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk63"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c -&gt; b /\ c</span></div></blockquote></div></div></small></span></pre><p>Let us see what is going on when we say
<code class="highlight coq"><span class="name builtin">move</span><span class="operator">/</span><span class="name">andP</span></code>:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk64" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk64"><span class="highlight"><span class="nb">move</span>=&gt; Hb.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b &amp;&amp; c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk65" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk65"><span class="highlight"><span class="kn">Check</span> @elimTF (b /\ c) (b &amp;&amp; c) true (@andP b c) Hb.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">elimTF andP Hb
     : b /\ c</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b &amp;&amp; c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk66" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk66"><span class="highlight"><span class="nb">move</span>: Hb.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c -&gt; b /\ c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk67" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk67"><span class="highlight"><span class="nb">move</span>/(@elimTF (b /\ c) (b &amp;&amp; c) true (@andP b c)).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c -&gt; b /\ c</span></div></blockquote></div></div></small></span></pre><p>But where <code class="highlight coq"><span class="name">elimTF</span></code> comes from? SSReflect uses
the mechanism of view hints which provide some
wrapping lemmas such as <code class="highlight coq"><span class="name">elimTF</span></code> above. The user
can add a new view hint using the <code class="highlight coq"><span class="keyword namespace">Hint</span> <span class="name">View</span></code>
vernacular <code class="highlight coq"><span class="keyword namespace">Hint View for move</span><span class="operator">/</span> <span class="name">elimTF</span><span class="operator">|</span><span class="literal number integer">3</span></code>.</p>
<p>Here <code class="highlight coq"><span class="name">elimTF</span></code> is declared as a view hint for
the <code class="highlight coq"><span class="name builtin">move</span><span class="operator">/</span></code> command. The (optional) number <code class="highlight coq"><span class="literal number integer">3</span></code>
specifies the number of implicit arguments
to be considered for the declared hint view lemma.</p>
<p>The <code class="highlight coq"><span class="name">ssrbool</span><span class="operator">.</span><span class="name">v</span></code> module already declares a
numbers of view hints, so adding new ones should
be justified. For instance, one might need to do
it if one defines a new logical connective.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span>: id.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>But why is <code class="highlight coq"><span class="name">elimTF</span></code>'s type so complex? Because
it's applicable not only in the case the goal's
top assumtion is of the form <code class="highlight coq"><span class="name">b</span> <span class="operator">&amp;&amp;</span> <span class="name">c</span></code>, but it also
works for <code class="highlight coq"><span class="name">b</span> <span class="operator">&amp;&amp;</span> <span class="name">c</span> <span class="operator">=</span> <span class="name">false</span></code>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk68" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk68"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">special_support_for_reflect_predicates&#39;</span> <span class="nv">b</span> <span class="nv">c</span> :
  (b &amp;&amp; c) = false -&gt; ~ (b /\ c).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c = false -&gt; ~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk69" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk69"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c = false -&gt; ~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk6a" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk6a"><span class="highlight"><span class="nb">move</span>/andP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b /\ c) -&gt; ~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk6b" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk6b"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(<span class="kr">fun</span> (<span class="nv">b</span> <span class="nv">c</span> : bool) (<span class="nv">_view_subject_</span> : b &amp;&amp; c = false) =&gt;
 <span class="nl">?Goal</span> (elimTF andP _view_subject_))</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b /\ c) -&gt; ~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk6c" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk6c"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c = false -&gt; ~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk6d" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk6d"><span class="highlight"><span class="nb">move</span>=&gt; Hb.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b &amp;&amp; c = false</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk6e" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk6e"><span class="highlight"><span class="kn">Check</span> @elimTF (b /\ c) (b &amp;&amp; c) false (@andP b c) Hb.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">elimTF andP Hb
     : ~ (b /\ c)</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">Hb</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b &amp;&amp; c = false</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">exact</span>: @elimTF (b /\ c) (b &amp;&amp; c) false (@andP b c) Hb.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Reflection views usually work in both
directions</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk6f" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk6f"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">special_support_for_reflect_predicates&#39;&#39;</span> (<span class="nv">b</span> <span class="nv">c</span> : bool) :
  b /\ c -&gt; b &amp;&amp; c.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c -&gt; b &amp;&amp; c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk70" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk70"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c -&gt; b &amp;&amp; c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk71" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk71"><span class="highlight"><span class="nb">move</span>=&gt; /andP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c -&gt; b &amp;&amp; c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk72" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk72"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(<span class="kr">fun</span> (<span class="nv">b</span> <span class="nv">c</span> : bool) (<span class="nv">_view_subject_</span> : b /\ c) =&gt;
 <span class="nl">?Goal</span> (introT andP _view_subject_))</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c -&gt; b &amp;&amp; c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk73" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk73"><span class="highlight"><span class="kn">About</span> introT.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">introT :
<span class="kr">forall</span> [P : <span class="kt">Prop</span>] [b : bool], reflect P b -&gt; P -&gt; b

introT <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> introT [P]%type_scope [b]%bool_scope _ _
introT <span class="kr">is</span> opaque
Expands to: Constant Coq.ssr.ssrbool.introT</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c -&gt; b &amp;&amp; c</span></div></blockquote></div></div></small></span></pre><p><code class="highlight coq"><span class="name">introT</span></code> view hint gets implicitly inserted
because it is also declared with <code class="highlight coq"><span class="keyword namespace">Hint</span> <span class="name">View</span></code>
command.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">done</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div>
<div class="section" id="switching-views-at-the-goal">
<h2>Switching views at the goal</h2>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk74" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk74"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">special_support_for_reflect_predicates&#39;&#39;&#39;</span> (<span class="nv">b</span> <span class="nv">c</span> : bool) :
  b /\ c -&gt; b &amp;&amp; c.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c -&gt; b &amp;&amp; c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk75" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk75"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c -&gt; b &amp;&amp; c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk76" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk76"><span class="highlight"><span class="nb">move</span>=&gt; bc.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b /\ c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c</span></div></blockquote></div></div></small></span></pre><p>If we'd like, instead of the assumption,
change the goal, we can use <code class="highlight coq"><span class="name builtin">apply</span><span class="operator">/</span></code> tactic:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk77" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk77"><span class="highlight"><span class="nb">apply</span>/andP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b /\ c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk78" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk78"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(<span class="kr">fun</span> (<span class="nv">b</span> <span class="nv">c</span> : bool) (<span class="nv">bc</span> : b /\ c) =&gt;
 [eta introTF andP] <span class="nl">?Goal</span>)</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b /\ c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c</span></div></blockquote></div></div></small></span></pre><p>In this case the <code class="highlight coq"><span class="name">introTF</span></code> view hint gets
inserted because the <code class="highlight coq"><span class="name">ssrbool</span></code> module introduces
the correspoding view hint: <code class="highlight coq"><span class="keyword namespace">Hint View for apply</span><span class="operator">/</span> <span class="name">introTF</span><span class="operator">|</span><span class="literal number integer">3</span></code></p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk79" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk79"><span class="highlight"><span class="kn">About</span> introTF.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">introTF :
<span class="kr">forall</span> [P : <span class="kt">Prop</span>] [b c : bool],
reflect P b -&gt; (<span class="kr">if</span> c <span class="kr">then</span> P <span class="kr">else</span> ~ P) -&gt; b = c

introTF <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> introTF [P]%type_scope [b c]%bool_scope _ _
introTF <span class="kr">is</span> opaque
Expands to: Constant Coq.ssr.ssrbool.introTF</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">bc</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">b /\ c</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b /\ c</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">done</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Again, <code class="highlight coq"><span class="name">introTF</span></code> is a general lemma to
accomodate goals of the form <code class="highlight coq"><span class="name">_</span> <span class="operator">=</span> <span class="name">false</span></code>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk7a" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk7a"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">special_support_for_reflect_predicates&#39;&#39;&#39;&#39;</span> (<span class="nv">b</span> <span class="nv">c</span> : bool) :
  ~ (b /\ c) -&gt; b &amp;&amp; c = false.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b /\ c) -&gt; b &amp;&amp; c = false</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk7b" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk7b"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b /\ c) -&gt; b &amp;&amp; c = false</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk7c" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk7c"><span class="highlight"><span class="nb">move</span>=&gt; ab.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ (b /\ c)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">b &amp;&amp; c = false</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk7d" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk7d"><span class="highlight"><span class="nb">apply</span>/andP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ (b /\ c)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk7e" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk7e"><span class="highlight"><span class="kn">Show Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">(<span class="kr">fun</span> (<span class="nv">b</span> <span class="nv">c</span> : bool) (<span class="nv">ab</span> : ~ (b /\ c)) =&gt;
 [eta introTF andP] <span class="nl">?Goal</span>)</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ (b /\ c)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk7f" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk7f"><span class="highlight"><span class="kn">About</span> introTF.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">introTF :
<span class="kr">forall</span> [P : <span class="kt">Prop</span>] [b c : bool],
reflect P b -&gt; (<span class="kr">if</span> c <span class="kr">then</span> P <span class="kr">else</span> ~ P) -&gt; b = c

introTF <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> introTF [P]%type_scope [b c]%bool_scope _ _
introTF <span class="kr">is</span> opaque
Expands to: Constant Coq.ssr.ssrbool.introTF</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">b, c</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">bool</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">ab</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">~ (b /\ c)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">~ (b /\ c)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">done</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Let's look at some more machinery to work with
specifiations for decision procedures. We are
going to look at the <code class="highlight coq"><span class="name builtin">eqn</span></code> -- the decision
procedure for equality on the <code class="highlight coq"><span class="name">nat</span></code> type.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk80" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk80"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">eqnP_my</span> (<span class="nv">n</span> <span class="nv">m</span> : nat) :
  reflect (n = m) (<span class="nb">eqn</span> n m).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (n = m) (<span class="nb">eqn</span> n m)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk81" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk81"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (n = m) (<span class="nb">eqn</span> n m)</span></div></blockquote></div></div></small></span></pre><p>One way to prove this is to turn [reflect]
into a bi-implication and prove the two directions
by induction separately. An idiomatic way to do
that is as follows:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk82" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk82"><span class="highlight"><span class="nb">apply</span>: (iffP idP).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nb">eqn</span> n m -&gt; n = m</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk83" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk83"><hr></label><div class="goal-conclusion"><span class="highlight">n = m -&gt; <span class="nb">eqn</span> n m</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk84" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk84"><span class="highlight"><span class="kn">About</span> iffP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">iffP :
<span class="kr">forall</span> [P Q : <span class="kt">Prop</span>] [b : bool],
reflect P b -&gt; (P -&gt; Q) -&gt; (Q -&gt; P) -&gt; reflect Q b

iffP <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> iffP [P Q]%type_scope [b]%bool_scope _ (_
  _)%function_scope
iffP <span class="kr">is</span> opaque
Expands to: Constant Coq.ssr.ssrbool.iffP</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nb">eqn</span> n m -&gt; n = m</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk85" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk85"><hr></label><div class="goal-conclusion"><span class="highlight">n = m -&gt; <span class="nb">eqn</span> n m</span></div></blockquote></div></div></div></small></span></pre><p>We need the trivial reflection view <code class="highlight coq"><span class="name">idP</span></code> here
to convert the boolean expression <code class="highlight coq"><span class="name builtin">eqn</span> <span class="name">n</span> <span class="name">m</span></code> to the
proposition <code class="highlight coq"><span class="name builtin">eqn</span> <span class="name">n</span> <span class="name">m</span> <span class="operator">=</span> <span class="name">true</span></code> (you don't see the <code class="highlight coq"><span class="operator">=</span>
<span class="name">true</span></code> part in the subgoals because of the
<code class="highlight coq"><span class="name">is_true</span></code> coercion).</p>
<p>The rest of the proof should be trivial at
this point.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk86" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk86"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="nb">eqn</span> n m -&gt; n = m</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk87" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk87"><hr></label><div class="goal-conclusion"><span class="highlight">n = m -&gt; <span class="nb">eqn</span> n m</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk88" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk88"><span class="highlight"><span class="bp">by</span> <span class="nb">elim</span>: n m =&gt; [|n IHn] [|m] //= /IHn-&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">n, m</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = m -&gt; <span class="nb">eqn</span> n m</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">move</span>=&gt; -&gt;; <span class="nb">elim</span>: m.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Here is an example of using <code class="highlight coq"><span class="name">iffP</span></code> with a
non-<code class="highlight coq"><span class="name">idP</span></code> argument. Here we use <code class="highlight coq"><span class="name">eqType</span></code> -- a type
with decidable equality and some machinery
associated with it, like <code class="highlight coq"><span class="name">eqP</span></code>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk89" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk89"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">nseqP</span> (<span class="nv">T</span> : eqType) <span class="nv">n</span> (<span class="nv">x</span> <span class="nv">y</span> : T) :
  reflect (y = x /\ n &gt; <span class="mi">0</span>) (y \<span class="kr">in</span> nseq n x).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (y = x /\ <span class="mi">0</span> &lt; n) (y \<span class="kr">in</span> nseq n x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk8a" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk8a"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (y = x /\ <span class="mi">0</span> &lt; n) (y \<span class="kr">in</span> nseq n x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk8b" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk8b"><span class="highlight"><span class="nb">rewrite</span> mem_nseq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (y = x /\ <span class="mi">0</span> &lt; n) ((<span class="mi">0</span> &lt; n) &amp;&amp; (y == x))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk8c" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk8c"><span class="highlight"><span class="nb">rewrite</span> andbC.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (y = x /\ <span class="mi">0</span> &lt; n) ((y == x) &amp;&amp; (<span class="mi">0</span> &lt; n))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk8d" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk8d"><span class="highlight"><span class="nb">apply</span>: (iffP andP).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y == x /\ <span class="mi">0</span> &lt; n -&gt; y = x /\ <span class="mi">0</span> &lt; n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk8e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk8e"><hr></label><div class="goal-conclusion"><span class="highlight">y = x /\ <span class="mi">0</span> &lt; n -&gt; y == x /\ <span class="mi">0</span> &lt; n</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk8f" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk8f"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y == x /\ <span class="mi">0</span> &lt; n -&gt; y = x /\ <span class="mi">0</span> &lt; n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk90" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk90"><hr></label><div class="goal-conclusion"><span class="highlight">y = x /\ <span class="mi">0</span> &lt; n -&gt; y == x /\ <span class="mi">0</span> &lt; n</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk91" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk91"><span class="highlight"><span class="nb">case</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y == x -&gt; <span class="mi">0</span> &lt; n -&gt; y = x /\ <span class="mi">0</span> &lt; n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk92" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk92"><hr></label><div class="goal-conclusion"><span class="highlight">y = x /\ <span class="mi">0</span> &lt; n -&gt; y == x /\ <span class="mi">0</span> &lt; n</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk93" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk93"><span class="highlight"><span class="nb">move</span>/eqP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y = x -&gt; <span class="mi">0</span> &lt; n -&gt; y = x /\ <span class="mi">0</span> &lt; n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk94" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk94"><hr></label><div class="goal-conclusion"><span class="highlight">y = x /\ <span class="mi">0</span> &lt; n -&gt; y == x /\ <span class="mi">0</span> &lt; n</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk95" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk95"><span class="highlight"><span class="kn">About</span> eqP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">eqP : <span class="kr">forall</span> {<span class="nv">T</span> : eqType}, Equality.axiom eq_op

eqP <span class="kr">is</span> not universe polymorphic
Expanded type <span class="kr">for</span> implicit arguments
eqP :
<span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">x</span> <span class="nv">y</span> : T},
reflect (x = y) (x == y)

<span class="kn">Arguments</span> eqP {T x y}
eqP <span class="kr">is</span> opaque
Expands to: Constant mathcomp.ssreflect.eqtype.eqP</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y = x -&gt; <span class="mi">0</span> &lt; n -&gt; y = x /\ <span class="mi">0</span> &lt; n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk96" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk96"><hr></label><div class="goal-conclusion"><span class="highlight">y = x /\ <span class="mi">0</span> &lt; n -&gt; y == x /\ <span class="mi">0</span> &lt; n</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk97" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk97"><span class="highlight"><span class="nb">move</span>=&gt;-&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight"><span class="mi">0</span> &lt; n -&gt; x = x /\ <span class="mi">0</span> &lt; n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk98" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk98"><hr></label><div class="goal-conclusion"><span class="highlight">y = x /\ <span class="mi">0</span> &lt; n -&gt; y == x /\ <span class="mi">0</span> &lt; n</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk99" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk99"><span class="highlight"><span class="bp">done</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y = x /\ <span class="mi">0</span> &lt; n -&gt; y == x /\ <span class="mi">0</span> &lt; n</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk9a" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk9a"><span class="highlight"><span class="nb">case</span>=&gt; -&gt;-&gt;.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">x == x /\ true</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk9b" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk9b"><span class="highlight"><span class="nb">rewrite</span> eq_refl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">true /\ true</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">done</span>.</span></span></span></pre><p>A more idiomatic solution</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk9c" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk9c"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (y = x /\ <span class="mi">0</span> &lt; n) (y \<span class="kr">in</span> nseq n x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk9d" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk9d"><span class="highlight"><span class="nb">rewrite</span> mem_nseq andbC; <span class="nb">apply</span>: (iffP andP) =&gt; [[/eqP]|[/eqP]].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">y = x -&gt; <span class="mi">0</span> &lt; n -&gt; y = x /\ <span class="mi">0</span> &lt; n</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chk9e" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chk9e"><hr></label><div class="goal-conclusion"><span class="highlight">y == x -&gt; <span class="mi">0</span> &lt; n -&gt; y == x /\ <span class="mi">0</span> &lt; n</span></div></blockquote></div></div></div></small></span></pre><p>There is some code duplication here which can
be reduced using <code class="highlight coq"><span class="operator">-[</span>   <span class="operator">]</span></code> syntax:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chk9f" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chk9f"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">T</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">eqType</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">x, y</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">T</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">reflect (y = x /\ <span class="mi">0</span> &lt; n) (y \<span class="kr">in</span> nseq n x)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> mem_nseq andbC; <span class="nb">apply</span>: (iffP andP)=&gt; -[/eqP].</span></span></span></pre><p>We cannot say just <code class="highlight coq"><span class="operator">[/</span><span class="name">eqP</span><span class="operator">]</span></code> because Coq
expects us to provide tactics for both subgoals
and not just one. To bypass this restriction we
use the <code class="highlight coq"><span class="operator">-</span></code> syntax.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre></div>
<div class="section" id="rewriting-with-reflect-predicates">
<h2>Rewriting with <code class="highlight coq"><span class="name">reflect</span></code> predicates</h2>
<p>One can rewrite with view lemmas if those
represent equations, like <code class="highlight coq"><span class="name">maxn_idPl</span></code>.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chka0" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chka0"><span class="highlight"><span class="kn">About</span> maxn_idPl.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">maxn_idPl :
<span class="kr">forall</span> {<span class="nv">m</span> <span class="nv">n</span> : nat}, reflect (maxn m n = m) (n &lt;= m)

maxn_idPl <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> maxn_idPl {m n}%nat_scope
maxn_idPl <span class="kr">is</span> opaque
Expands to: Constant
mathcomp.ssreflect.ssrnat.maxn_idPl</span></blockquote></div></div></small></span></pre><p>Let's see an example:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chka1" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chka1"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">leq_max</span> <span class="nv">m</span> <span class="nv">n1</span> <span class="nv">n2</span> :
  (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chka2" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chka2"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chka3" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chka3"><span class="highlight"><span class="nb">case</span>/orP: (leq_total n2 n1) =&gt; [le_n21 | le_n12].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chka4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chka4"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chka5" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chka5"><span class="highlight"><span class="kn">About</span> leq_total.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">leq_total : <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, (m &lt;= n) || (n &lt;= m)

leq_total <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> leq_total (_ _)%nat_scope
leq_total <span class="kr">is</span> opaque
Expands to: Constant
mathcomp.ssreflect.ssrnat.leq_total</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chka6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chka6"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chka7" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chka7"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chka8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chka8"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chka9" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chka9"><span class="highlight"><span class="kn">Search</span> (maxn <span class="nl">?n1</span> <span class="nl">?n2</span> = <span class="nl">?n1</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">minKn: <span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat, maxn n (minn m n) = n</span></blockquote><blockquote class="alectryon-message"><span class="highlight">maxn_idPl:
  <span class="kr">forall</span> {<span class="nv">m</span> <span class="nv">n</span> : nat}, reflect (maxn m n = m) (n &lt;= m)</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkaa" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkaa"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp">  </span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkab" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkab"><span class="highlight"><span class="nb">rewrite</span> (maxn_idPl le_n21).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= n1) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkac" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkac"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small></span></pre><p>Why does this trick work?</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkad" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkad"><span class="highlight"><span class="kn">Check</span> (maxn_idPl le_n21).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">maxn_idPl le_n21
     : maxn n1 n2 = n1</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= n1) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkae" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkae"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small></span></pre><p>OK, this is an ordinary equation, no wonder
<code class="highlight coq"><span class="name builtin">rewrite</span></code> works. The view lemma [maxn_idPl] is
<em>not</em> a function but behaves like one here. Let us
check coercions!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkaf" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkaf"><span class="highlight"><span class="kn">Set Printing Coercions</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (n2 &lt;= n1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= n1) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkb0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (n1 &lt;= n2)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkb0"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkb1" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkb1"><span class="highlight"><span class="kn">Check</span> (maxn_idPl le_n21).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">elimT maxn_idPl le_n21
     : maxn n1 n2 = n1</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (n2 &lt;= n1)</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= n1) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkb2" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">is_true (n1 &lt;= n2)</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkb2"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small></span></pre><p>No magic: <code class="highlight coq"><span class="name">elimT</span></code> get implicitly inserted.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkb3" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkb3"><span class="highlight"><span class="kn">Unset Printing Coercions</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= n1) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkb4" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkb4"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkb5" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkb5"><span class="highlight"><span class="kn">About</span> elimT.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">elimT :
<span class="kr">forall</span> [P : <span class="kt">Prop</span>] [b : bool], reflect P b -&gt; b -&gt; P

elimT <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> elimT [P]%type_scope [b]%bool_scope _ _
elimT <span class="kr">is</span> a coercion
elimT <span class="kr">is</span> opaque
Expands to: Constant Coq.ssr.ssrbool.elimT</span></blockquote></div><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= n1) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkb6" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkb6"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small></span></pre><p><code class="highlight coq"><span class="name">elimT</span></code> is a coercion from <code class="highlight coq"><span class="name">reflect</span></code> to
<code class="highlight coq"><span class="keyword type">Funclass</span></code>, which means it gets inserted when one
uses a view lemma as a function.</p>
<p>Essentially we invoke the following tactic:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkb7" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkb7"><span class="highlight"><span class="kn">Undo</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkb8" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkb8"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkb9" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkb9"><span class="highlight"><span class="nb">rewrite</span> (elimT maxn_idPl le_n21).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= n1) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkba" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n12</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n1 &lt;= n2</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkba"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small></span></pre><p>One can easily finish the proof, but let's
simplify it first.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkbb" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkbb"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></small></span></pre><p>We remove the symmetrical case first:</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkbc" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkbc"><span class="highlight"><span class="nb">without loss</span> le_n21: n1 n2 / n2 &lt;= n1.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
 n2 &lt;= n1 -&gt;
 (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)) -&gt;
(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkbd" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkbd"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkbe" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkbe"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(<span class="kr">forall</span> <span class="nv">n1</span> <span class="nv">n2</span> : nat,
 n2 &lt;= n1 -&gt;
 (m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)) -&gt;
(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkbf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkbf"><hr></label><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc0" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc0"><span class="highlight"><span class="bp">by</span> <span class="nb">case</span>/orP: (leq_total n2 n1) =&gt; le; <span class="nb">last</span> <span class="nb">rewrite</span> maxnC orbC; <span class="nb">apply</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= maxn n1 n2) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc1" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc1"><span class="highlight"><span class="nb">rewrite</span> (maxn_idPl le_n21).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n1, n2</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">le_n21</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n2 &lt;= n1</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">(m &lt;= n1) = (m &lt;= n1) || (m &lt;= n2)</span></div></blockquote></div></div></small></span></pre><p>The rest is an exercise</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Abort</span>.</span></span></span></pre></div>
<div class="section" id="a-specification-example">
<h2>A specification example</h2>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc2" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc2"><span class="highlight"><span class="kn">About</span> allP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">allP :
<span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">a</span> : pred T} {<span class="nv">s</span> : seq T},
reflect {<span class="kr">in</span> s, <span class="kr">forall</span> <span class="nv">x</span> : T, a x} (<span class="kp">all</span> a s)

allP <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> allP {T a} {s}%seq_scope
allP <span class="kr">is</span> opaque
Expands to: Constant mathcomp.ssreflect.seq.allP</span></blockquote></div></div></small></span></pre><p>Check out some other specs in the <code class="highlight coq"><span class="name">seq</span></code> and
<code class="highlight coq"><span class="name">ssrnat</span></code> modules!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc3" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc3"><span class="highlight"><span class="kn">Search</span> reflect <span class="kn">inside</span> seq.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">nilP:
  <span class="kr">forall</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">s</span> : seq T},
  reflect (s = [::]) (nilp s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">all_filterP:
  <span class="kr">forall</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">a</span> : pred T} {<span class="nv">s</span> : seq T},
  reflect ([seq x &lt;- s | a x] = s) (<span class="kp">all</span> a s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">perm_nilP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">s</span> : seq T},
  reflect (s = [::]) (perm_eq s [::])</span></blockquote><blockquote class="alectryon-message"><span class="highlight">natnseq0P:
  <span class="kr">forall</span> <span class="nv">s</span> : seq nat,
  reflect (s = nseq (size s) <span class="mi">0</span>) (sumn s == <span class="mi">0</span>)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">permPl:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">s1</span> <span class="nv">s2</span> : seq T},
  reflect (perm_eql s1 s2) (perm_eq s1 s2)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">permPr:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">s1</span> <span class="nv">s2</span> : seq T},
  reflect (perm_eq^~ s1 =<span class="mi">1</span> perm_eq^~ s2)
    (perm_eq s1 s2)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">all_nthP:
  <span class="kr">forall</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">a</span> : pred T} {<span class="nv">s</span> : seq T} (<span class="nv">x0</span> : T),
  reflect
    (<span class="kr">forall</span> <span class="nv">i</span> : nat, i &lt; size s -&gt; a (nth x0 s i))
    (<span class="kp">all</span> a s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">constantP:
  <span class="kr">forall</span> [T : eqType],
  T -&gt;
  <span class="kr">forall</span> <span class="nv">s</span> : seq T,
  reflect (<span class="kr">exists</span> <span class="nv">x</span> : T, s = nseq (size s) x)
    (constant s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">all_pred1P:
  <span class="kr">forall</span> [T : eqType] (x : T) (s : seq T),
  reflect (s = nseq (size s) x) (<span class="kp">all</span> (pred1 x) s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">has_nthP:
  <span class="kr">forall</span> {<span class="nv">T</span> : <span class="kt">Type</span>} {<span class="nv">a</span> : pred T} {<span class="nv">s</span> : seq T} (<span class="nv">x0</span> : T),
  reflect
    (<span class="kr">exists2</span> i : nat, i &lt; size s &amp; a (nth x0 s i))
    (has a s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">permP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">s1</span> <span class="nv">s2</span> : seq T},
  reflect (count^~ s1 =<span class="mi">1</span> count^~ s2) (perm_eq s1 s2)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">allP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">a</span> : pred T} {<span class="nv">s</span> : seq T},
  reflect {<span class="kr">in</span> s, <span class="kr">forall</span> <span class="nv">x</span> : T, a x} (<span class="kp">all</span> a s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">hasP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">a</span> : pred T} {<span class="nv">s</span> : seq T},
  reflect (<span class="kr">exists2</span> x : T, x \<span class="kr">in</span> s &amp; a x) (has a s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">count_memPn:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">x</span> : T} {<span class="nv">s</span> : seq T},
  reflect (count_mem x s = <span class="mi">0</span>) (x \notin s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">seq.nseqP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">n</span> : nat} {<span class="nv">x</span> <span class="nv">y</span> : T},
  reflect (y = x /\ <span class="mi">0</span> &lt; n) (y \<span class="kr">in</span> nseq n x)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">subseqP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">s1</span> <span class="nv">s2</span> : seq T},
  reflect
    (<span class="kr">exists2</span> m : seq bool,
       size m = size s2 &amp; s1 = mask m s2)
    (subseq s1 s2)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">allPP:
  <span class="kr">forall</span> [T : eqType] [a : pred T] (s : seq T)
    [A : T -&gt; <span class="kt">Prop</span>],
  (<span class="kr">forall</span> <span class="nv">x</span> : T, reflect (A x) (a x)) -&gt;
  reflect {<span class="kr">in</span> s, <span class="kr">forall</span> <span class="nv">x</span> : T, A x} (<span class="kp">all</span> a s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">allPn:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">a</span> : pred T} {<span class="nv">s</span> : seq T},
  reflect (<span class="kr">exists2</span> x : T, x \<span class="kr">in</span> s &amp; ~~ a x)
    (~~ <span class="kp">all</span> a s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">hasPn:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">a</span> : pred T} {<span class="nv">s</span> : seq T},
  reflect {<span class="kr">in</span> s, <span class="kr">forall</span> <span class="nv">x</span> : T, ~~ a x} (~~ has a s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">subseq_uniqP:
  <span class="kr">forall</span> [T : eqType] [s1 s2 : seq T],
  uniq s2 -&gt;
  reflect (s1 = [seq x &lt;- s2 | mem s1 x])
    (subseq s1 s2)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">hasPP:
  <span class="kr">forall</span> [T : eqType] [a : pred T] (s : seq T)
    [A : T -&gt; <span class="kt">Prop</span>],
  (<span class="kr">forall</span> <span class="nv">x</span> : T, reflect (A x) (a x)) -&gt;
  reflect (<span class="kr">exists2</span> x : T, x \<span class="kr">in</span> s &amp; A x) (has a s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">nthP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">s</span> : seq T} {<span class="nv">x</span> : T} (<span class="nv">x0</span> : T),
  reflect
    (<span class="kr">exists2</span> i : nat, i &lt; size s &amp; nth x0 s i = x)
    (x \<span class="kr">in</span> s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">perm_consP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">x</span> : T} {<span class="nv">s</span> <span class="nv">t</span> : seq T},
  reflect
    (<span class="kr">exists</span> (<span class="nv">i</span> : nat) (<span class="nv">u</span> : seq T),
       rot i t = x :: u /\ perm_eq u s)
    (perm_eq t (x :: s))</span></blockquote><blockquote class="alectryon-message"><span class="highlight">uniqPn:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} (<span class="nv">x0</span> : T) {<span class="nv">s</span> : seq T},
  reflect
    (<span class="kr">exists</span> <span class="nv">i</span> <span class="nv">j</span> : nat,
       [/\ i &lt; j, j &lt; size s
         &amp; nth x0 s i = nth x0 s j]) (~~ uniq s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">mapP:
  <span class="kr">forall</span> {<span class="nv">T1</span> <span class="nv">T2</span> : eqType} {<span class="nv">f</span> : T1 -&gt; T2} {<span class="nv">s</span> : seq T1}
    {<span class="nv">y</span> : T2},
  reflect (<span class="kr">exists2</span> x : T1, x \<span class="kr">in</span> s &amp; y = f x)
    (y \<span class="kr">in</span> [seq f i | i &lt;- s])</span></blockquote><blockquote class="alectryon-message"><span class="highlight">uniqP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} (<span class="nv">x0</span> : T) {<span class="nv">s</span> : seq T},
  reflect {<span class="kr">in</span> gtn (size s) &amp;, injective (nth x0 s)}
    (uniq s)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">flattenP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">A</span> : seq (seq T)} {<span class="nv">x</span> : T},
  reflect
    (<span class="kr">exists2</span> s : seq_eqType T, s \<span class="kr">in</span> A &amp; x \<span class="kr">in</span> s)
    (x \<span class="kr">in</span> flatten A)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">perm_iotaP:
  <span class="kr">forall</span> {<span class="nv">T</span> : eqType} {<span class="nv">s</span> <span class="nv">t</span> : seq T} (<span class="nv">x0</span> : T),
  <span class="kr">let</span> <span class="nv">It</span> := iota <span class="mi">0</span> (size t) <span class="kr">in</span>
  reflect
    (<span class="kr">exists2</span> Is : seq nat_eqType,
       perm_eq Is It &amp; s = [seq nth x0 t i | i &lt;- Is])
    (perm_eq s t)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">leq_uniq_countP:
  <span class="kr">forall</span> [T : eqType] (x : T) [s1 : seq T]
    (s2 : seq T),
  uniq s1 -&gt;
  reflect (x \<span class="kr">in</span> s1 -&gt; x \<span class="kr">in</span> s2)
    (count_mem x s1 &lt;= count_mem x s2)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">allrelP:
  <span class="kr">forall</span> {<span class="nv">T</span> <span class="nv">S</span> : eqType} {<span class="nv">r</span> : T -&gt; S -&gt; bool}
    {<span class="nv">xs</span> : seq_predType T} {<span class="nv">ys</span> : seq_predType S},
  reflect {<span class="kr">in</span> xs &amp; ys, <span class="kr">forall</span> (<span class="nv">x</span> : T) (<span class="nv">y</span> : S), r x y}
    (allrel r xs ys)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">flatten_mapP:
  <span class="kr">forall</span> {<span class="nv">S</span> <span class="nv">T</span> : eqType} {<span class="nv">A</span> : S -&gt; seq T}
    {<span class="nv">s</span> : seq_predType S} {<span class="nv">y</span> : T},
  reflect (<span class="kr">exists2</span> x : S, x \<span class="kr">in</span> s &amp; y \<span class="kr">in</span> A x)
    (y \<span class="kr">in</span> flatten [seq A i | i &lt;- s])</span></blockquote><blockquote class="alectryon-message"><span class="highlight">all_allpairsP:
  <span class="kr">forall</span> {<span class="nv">S</span> : eqType} {<span class="nv">T</span> : S -&gt; eqType} {<span class="nv">R</span> : <span class="kt">Type</span>}
    {<span class="nv">p</span> : pred R} {<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : S, T x -&gt; R}
    {<span class="nv">s</span> : seq S} {<span class="nv">t</span> : <span class="kr">forall</span> <span class="nv">x</span> : S, seq (T x)},
  reflect
    (<span class="kr">forall</span> (<span class="nv">x</span> : S) (<span class="nv">y</span> : T x),
     x \<span class="kr">in</span> s -&gt; y \<span class="kr">in</span> t x -&gt; p (f x y))
    (<span class="kp">all</span> p [seq f x y | x &lt;- s, y &lt;- t x])</span></blockquote><blockquote class="alectryon-message"><span class="highlight">allpairsPdep:
  <span class="kr">forall</span> {<span class="nv">S</span> : eqType} {<span class="nv">T</span> : S -&gt; eqType} {<span class="nv">R</span> : eqType}
    {<span class="nv">f</span> : <span class="kr">forall</span> <span class="nv">x</span> : S, T x -&gt; R} {<span class="nv">s</span> : seq S}
    {<span class="nv">t</span> : <span class="kr">forall</span> <span class="nv">x</span> : S, seq (T x)} {<span class="nv">z</span> : R},
  reflect
    (<span class="kr">exists</span> (<span class="nv">x</span> : S) (<span class="nv">y</span> : T x),
       [/\ x \<span class="kr">in</span> s, y \<span class="kr">in</span> t x &amp; z = f x y])
    (z \<span class="kr">in</span> [seq f x y | x &lt;- s, y &lt;- t x])</span></blockquote><blockquote class="alectryon-message"><span class="highlight">allpairsP:
  <span class="kr">forall</span> {<span class="nv">S</span> <span class="nv">T</span> <span class="nv">R</span> : eqType} {<span class="nv">f</span> : S -&gt; T -&gt; R}
    {<span class="nv">s</span> : seq S} {<span class="nv">t</span> : seq T} {<span class="nv">z</span> : R},
  reflect
    (<span class="kr">exists</span> <span class="nv">p</span> : S * T,
       [/\ p.<span class="mi">1</span> \<span class="kr">in</span> s, p.<span class="mi">2</span> \<span class="kr">in</span> t &amp; z = f p.<span class="mi">1</span> p.<span class="mi">2</span>])
    (z \<span class="kr">in</span> [seq f x y | x &lt;- s, y &lt;- t])</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc4" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc4"><span class="highlight"><span class="kn">Search</span> reflect <span class="kn">inside</span> ssrnat.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">leqif_refl:
  <span class="kr">forall</span> (<span class="nv">m</span> : nat) (<span class="nv">C</span> : bool),
  reflect (m &lt;= m ?= iff C) C</span></blockquote><blockquote class="alectryon-message"><span class="highlight">leP:
  <span class="kr">forall</span> {<span class="nv">m</span> <span class="nv">n</span> : nat},
  reflect (m &lt;= n)%coq_nat (m &lt;= n)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">ltP:
  <span class="kr">forall</span> {<span class="nv">m</span> <span class="nv">n</span> : nat}, reflect (m &lt; n)%coq_nat (m &lt; n)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">minn_idPr:
  <span class="kr">forall</span> {<span class="nv">m</span> <span class="nv">n</span> : nat}, reflect (minn m n = n) (n &lt;= m)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">minn_idPl:
  <span class="kr">forall</span> {<span class="nv">m</span> <span class="nv">n</span> : nat}, reflect (minn m n = m) (m &lt;= n)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">maxn_idPr:
  <span class="kr">forall</span> {<span class="nv">m</span> <span class="nv">n</span> : nat}, reflect (maxn m n = n) (m &lt;= n)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">maxn_idPl:
  <span class="kr">forall</span> {<span class="nv">m</span> <span class="nv">n</span> : nat}, reflect (maxn m n = m) (n &lt;= m)</span></blockquote><blockquote class="alectryon-message"><span class="highlight">leqifP:
  <span class="kr">forall</span> (<span class="nv">m</span> <span class="nv">n</span> : nat) (<span class="nv">C</span> : bool),
  reflect (m &lt;= n ?= iff C)
    (<span class="kr">if</span> C <span class="kr">then</span> m == n <span class="kr">else</span> m &lt; n)</span></blockquote></div></div></small></span></pre><p>The <code class="highlight coq"><span class="keyword namespace">inside</span></code> syntax lets one look for lemmas
inside a particular module only.</p>
</div>
</div>
<div class="section" id="specs-as-rewrite-mutli-rules">
<h1>Specs as rewrite mutli-rules</h1>
<p>We have seen <code class="highlight coq"><span class="name">reflect</span></code>-predicates being able
to rewrite boolean expressions corresponding to
its index. We can take this approach even further.
Let's see an example of a mutli-rule.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc5" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc5"><span class="highlight"><span class="kn">Example</span> <span class="nf">for_ltngtP</span> <span class="nv">m</span> <span class="nv">n</span> :
  (m &lt;= n) &amp;&amp; (n &lt;= m) -&gt;
  (m == n) || (m &gt; n) || (m + n == <span class="mi">0</span>).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;= n &lt;= m -&gt; (m == n) || (n &lt; m) || (m + n == <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc6" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc6"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;= n &lt;= m -&gt; (m == n) || (n &lt; m) || (m + n == <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">case</span>: ltngtP.</span></span></span></pre><p>That was quick!</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc7" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc7"><span class="highlight"><span class="kn">About</span> ltngtP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">ltngtP :
<span class="kr">forall</span> <span class="nv">m</span> <span class="nv">n</span> : nat,
compare_nat m n (minn n m) (minn m n) (maxn n m)
  (maxn m n) (n == m) (m == n) (n &lt;= m) (m &lt;= n)
  (n &lt; m) (m &lt; n)

ltngtP <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> ltngtP (_ _)%nat_scope
ltngtP <span class="kr">is</span> opaque
Expands to: Constant mathcomp.ssreflect.ssrnat.ltngtP</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc8" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc8"><span class="highlight"><span class="kn">About</span> compare_nat.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-messages"><blockquote class="alectryon-message"><span class="highlight">compare_nat :
nat -&gt;
nat -&gt;
nat -&gt;
nat -&gt;
nat -&gt;
nat -&gt;
bool -&gt; bool -&gt; bool -&gt; bool -&gt; bool -&gt; bool -&gt; <span class="kt">Set</span>

compare_nat <span class="kr">is</span> not universe polymorphic
<span class="kn">Arguments</span> compare_nat (_ _ _ _ _ _)%nat_scope (_ _ _ _
  _ _)%bool_scope
Expands to: <span class="kn">Inductive</span>
<span class="nf">mathcomp</span>.ssreflect.ssrnat.compare_nat</span></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-wsp"><span class="highlight">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkc9" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkc9"><span class="highlight"><span class="kn">Restart</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt;= n &lt;= m -&gt; (m == n) || (n &lt; m) || (m + n == <span class="mi">0</span>)</span></div></blockquote></div></div></small></span></pre><p><code class="highlight coq"><span class="name builtin">case</span><span class="operator">:</span> <span class="name">ltngtP</span></code> performs case analysis: it
generates three subgoals corresponding to thee
three cases, strictly less, equal, strictly
greater.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkca" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkca"><span class="highlight"><span class="nb">case</span>: ltngtP.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n &lt; m -&gt;
false &amp;&amp; true -&gt; false || true || (m + n == <span class="mi">0</span>)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkcb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkcb"><hr></label><div class="goal-conclusion"><span class="highlight">m &lt; n -&gt;
true &amp;&amp; false -&gt; false || false || (m + n == <span class="mi">0</span>)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkcc" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkcc"><hr></label><div class="goal-conclusion"><span class="highlight">n = m -&gt; true &amp;&amp; true -&gt; true || false || (m + n == <span class="mi">0</span>)</span></div></blockquote></div></div></div></small></span></pre><p>Notice that a lot of boolean expressions got
replaced with <code class="highlight coq"><span class="name">true</span></code> or <code class="highlight coq"><span class="name">false</span></code> depending on a
concrete case we are covering. The <code class="highlight coq"><span class="name">ltngtP</span></code> also
works as a rewrite rule.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkcd" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkcd"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n &lt; m -&gt;
false &amp;&amp; true -&gt; false || true || (m + n == <span class="mi">0</span>)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkce" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkce"><hr></label><div class="goal-conclusion"><span class="highlight">m &lt; n -&gt;
true &amp;&amp; false -&gt; false || false || (m + n == <span class="mi">0</span>)</span></div></blockquote><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkcf" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkcf"><hr></label><div class="goal-conclusion"><span class="highlight">n = m -&gt; true &amp;&amp; true -&gt; true || false || (m + n == <span class="mi">0</span>)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkd0" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkd0"><span class="highlight"><span class="bp">done</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt; n -&gt;
true &amp;&amp; false -&gt; false || false || (m + n == <span class="mi">0</span>)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkd1" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkd1"><hr></label><div class="goal-conclusion"><span class="highlight">n = m -&gt; true &amp;&amp; true -&gt; true || false || (m + n == <span class="mi">0</span>)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkd2" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkd2"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">m &lt; n -&gt;
true &amp;&amp; false -&gt; false || false || (m + n == <span class="mi">0</span>)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkd3" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkd3"><hr></label><div class="goal-conclusion"><span class="highlight">n = m -&gt; true &amp;&amp; true -&gt; true || false || (m + n == <span class="mi">0</span>)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkd4" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkd4"><span class="highlight"><span class="bp">done</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = m -&gt; true &amp;&amp; true -&gt; true || false || (m + n == <span class="mi">0</span>)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkd5" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkd5"><span class="highlight"><span class="nb">move</span>=&gt;/=.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n = m -&gt; true -&gt; true</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">done</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span></span></pre><p>Let's see how one can implement this combined
lemma.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Module</span> <span class="nf">Trichotomy</span>.</span></span></span></pre><p>First, we define a type family (indexed type)
with indices corresponding to expressions we want
to rewrite in subgoals. We use the <code class="highlight coq"><span class="keyword namespace">Variant</span></code>
vernacular here which is exactly like <code class="highlight coq"><span class="keyword namespace">Inductive</span></code>
but the type cannot refer to itself in its
definition, in other words it's a non-recursive
inductive type.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Variant</span> <span class="nf">compare_nat</span> <span class="nv">m</span> <span class="nv">n</span> :
   bool -&gt; bool -&gt; bool -&gt; bool -&gt; bool -&gt; bool -&gt; <span class="kt">Type</span> :=
| CompareNatLt of m &lt; n :
   compare_nat m n false false false true false true
| CompareNatGt of m &gt; n :
   compare_nat m n false false true false true false
| CompareNatEq of m = n :
   compare_nat m n true true true true false false.</span></span></span></pre><p>Next, we define a specification lemma which
connect the type family above with concrete
expressions we want to rewrite.</p>
<pre class="alectryon-io"><!-- Generator: Alectryon --><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkd6" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkd6"><span class="highlight"><span class="kn">Lemma</span> <span class="nf">ltngtP</span> <span class="nv">m</span> <span class="nv">n</span> :
  compare_nat m n (n == m) (m == n) (n &lt;= m)
                  (m &lt;= n) (n &lt; m) (m &lt; n).</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">compare_nat m n (n == m) (m == n) (n &lt;= m) (m &lt;= n)
  (n &lt; m) (m &lt; n)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkd7" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkd7"><span class="highlight"><span class="kn">Proof</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">compare_nat m n (n == m) (m == n) (n &lt;= m) (m &lt;= n)
  (n &lt; m) (m &lt; n)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkd8" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkd8"><span class="highlight"><span class="nb">rewrite</span> !ltn_neqAle [_ == n]eq_sym; <span class="nb">case</span>: ltnP =&gt; [nm|].</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">nm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt; n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">compare_nat m n (n == m) (n == m) false (m &lt;= n)
  ((n != m) &amp;&amp; false) ((n != m) &amp;&amp; (m &lt;= n))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkd9" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkd9"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m -&gt;
compare_nat m n (n == m) (n == m) true (m &lt;= n)
  ((n != m) &amp;&amp; true) ((n != m) &amp;&amp; (m &lt;= n))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkda" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkda"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">nm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt; n</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">compare_nat m n (n == m) (n == m) false (m &lt;= n)
  ((n != m) &amp;&amp; false) ((n != m) &amp;&amp; (m &lt;= n))</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkdb" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkdb"><hr></label><div class="goal-conclusion"><span class="highlight">n &lt;= m -&gt;
compare_nat m n (n == m) (n == m) true (m &lt;= n)
  ((n != m) &amp;&amp; true) ((n != m) &amp;&amp; (m &lt;= n))</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkdc" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkdc"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> ltnW // gtn_eqF //; <span class="nb">constructor</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">n &lt;= m -&gt;
compare_nat m n (n == m) (n == m) true (m &lt;= n)
  ((n != m) &amp;&amp; true) ((n != m) &amp;&amp; (m &lt;= n))</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkdd" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkdd"><span class="highlight"><span class="nb">rewrite</span> leq_eqVlt; <span class="nb">case</span>: ltnP; <span class="nb">rewrite</span> ?(orbT, orbF) =&gt; //= lt_mn eq_nm.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lt_mn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n &lt; m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_nm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">compare_nat m n (n == m) (n == m) true false
  ((n != m) &amp;&amp; true) ((n != m) &amp;&amp; false)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chkde" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lt_mn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;= n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_nm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n == m</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chkde"><hr></label><div class="goal-conclusion"><span class="highlight">compare_nat m n (n == m) 
  (n == m) true true ((n != m) &amp;&amp; true)
  ((n != m) &amp;&amp; true)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chkdf" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chkdf"><span class="highlight">-</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lt_mn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n &lt; m</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_nm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">true</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">compare_nat m n (n == m) (n == m) true false
  ((n != m) &amp;&amp; true) ((n != m) &amp;&amp; false)</span></div></blockquote><div class="alectryon-extra-goals"><input class="alectryon-extra-goal-toggle" id="lecture07-v-chke0" style="display: none" type="checkbox"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lt_mn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;= n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_nm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n == m</span></span></span></span></div></div><label class="goal-separator alectryon-extra-goal-label" for="lecture07-v-chke0"><hr></label><div class="goal-conclusion"><span class="highlight">compare_nat m n (n == m) 
  (n == m) true true ((n != m) &amp;&amp; true)
  ((n != m) &amp;&amp; true)</span></div></blockquote></div></div></div></small><span class="alectryon-wsp"> </span></span><span class="alectryon-sentence"><input class="alectryon-toggle" id="lecture07-v-chke1" style="display: none" type="checkbox"><label class="alectryon-input" for="lecture07-v-chke1"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> ltn_eqF //; <span class="nb">constructor</span>.</span></label><small class="alectryon-output"><div class="alectryon-output-sticky-wrapper"><div class="alectryon-goals"><blockquote class="alectryon-goal"><div class="goal-hyps"><div class="goal-hyp"><span class="hyp-names">m, n</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">nat</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">lt_mn</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">m &lt;= n</span></span></span></span></div><div class="goal-hyp"><span class="hyp-names">eq_nm</span><span><span class="hyp-type-block"><span class="hyp-punct">:</span><span class="hyp-type"><span class="highlight">n == m</span></span></span></span></div></div><span class="goal-separator"><hr></span><div class="goal-conclusion"><span class="highlight">compare_nat m n (n == m) (n == m) true true
  ((n != m) &amp;&amp; true) ((n != m) &amp;&amp; true)</span></div></blockquote></div></div></small><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="bp">by</span> <span class="nb">rewrite</span> eq_nm; <span class="nb">constructor</span>; <span class="nb">apply</span>/esym/eqP.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">Qed</span>.</span></span><span class="alectryon-wsp">
</span></span><span class="alectryon-sentence"><span class="alectryon-input"><span class="highlight"><span class="kn">End</span> <span class="nf">Trichotomy</span>.</span></span></span></pre><p>We can take this proof apart during a seminar
but here are things to observe here:</p>
<blockquote>
<ul class="simple">
<li>The <code class="highlight coq"><span class="name builtin">rewrite</span></code> tactic support a language of
patterns to focus rewriting on a particular
part of the goal, e.g. in this case rewrite
will only happen in a subterm corresponding to
the <code class="highlight coq"><span class="name">_</span> <span class="operator">==</span> <span class="name">n</span></code> pattern.</li>
<li>The <code class="highlight coq"><span class="name">ltnP</span></code> spec lemma which is like <code class="highlight coq"><span class="name">ltngtP</span></code>
but simpler.</li>
<li>Just like one can do chained transformations of
the top of the goal stack, one can do it for
the conclusion: <code class="highlight coq"><span class="name builtin">apply</span><span class="operator">/</span><span class="name">esym</span><span class="operator">/</span><span class="name">eqP</span></code>.</li>
</ul>
</blockquote>
</div>
<div class="section" id="summary">
<h1>Summary</h1>
<div class="section" id="vernacular">
<h2>Vernacular</h2>
<ul class="simple">
<li><code class="highlight coq"><span class="keyword namespace">Set Printing Coercions</span></code>: turn on printing of
implicit coercions -- very useful to better
understand goals.</li>
<li><code class="highlight coq"><span class="keyword namespace">Search</span> <span class="operator">&lt;</span><span class="name builtin">pattern</span><span class="operator">&gt;</span> <span class="keyword namespace">inside</span> <span class="operator">&lt;</span><span class="name">module</span><span class="operator">&gt;</span></code>: narrow the
scope of searching to a particular <code class="highlight coq"><span class="name">module</span></code>.</li>
</ul>
</div>
<div class="section" id="tactic-tactical-summary">
<h2>Tactic/tactical summary</h2>
<ul class="simple">
<li><code class="highlight coq"><span class="operator">-</span></code> action: can be used to connect unrelated
views (<code class="highlight coq"><span class="name builtin">move</span><span class="operator">=&gt;</span> <span class="operator">/</span><span class="name">V1</span> <span class="operator">-</span> <span class="operator">/</span><span class="name">V2</span></code>) or to force the
interpretation of <code class="highlight coq"><span class="operator">[]</span></code> as <em>case splitting</em> when
multiple subgoals are generated; <code class="highlight coq"><span class="operator">-[/</span><span class="name">eqP</span><span class="operator">]</span></code>.</li>
<li><code class="highlight coq"><span class="name builtin">case</span> <span class="keyword namespace">ident</span><span class="operator">:</span> <span class="name">term</span></code>: case analyse on <code class="highlight coq"><span class="name">term</span></code> and
keep the corresponding equation in the context
under the name of <code class="highlight coq"><span class="keyword namespace">ident</span></code>.</li>
<li><code class="highlight coq"><span class="name builtin">case</span><span class="operator">:</span> <span class="name">index_pattern</span> <span class="operator">/</span> <span class="name">type_family</span></code>: case
analyse on a term of indexed type and perform
substitutions of its indices according to
<code class="highlight coq"><span class="name">index_pattern</span></code>.</li>
<li><code class="highlight coq"><span class="name builtin">constructor</span></code>: try to pick a data constructor
automatically.</li>
<li><code class="highlight coq"><span class="name builtin">intuition</span></code>: a solver for propositional
intuitionistic logic.</li>
<li><code class="highlight coq"><span class="name builtin">without loss</span></code> or <code class="highlight coq"><span class="name builtin">wlog</span></code>: &quot;without loss of
generality&quot;-style reasoning.</li>
<li><code class="highlight coq"><span class="name builtin">apply</span><span class="operator">/</span><span class="name">view_lemma</span></code>: use the view mechanism on
the conclusion of the goal. Can be chained
together like <code class="highlight coq"><span class="name builtin">apply</span><span class="operator">/</span><span class="name">VL1</span><span class="operator">/</span><span class="name">VL2</span><span class="operator">/</span><span class="name">VL3</span></code>.</li>
<li><code class="highlight coq"><span class="name builtin">rewrite</span></code> tactic supports patterns: <code class="highlight coq"><span class="name builtin">rewrite</span>
<span class="operator">[&lt;</span><span class="name builtin">pattern</span><span class="operator">&gt;]&lt;</span><span class="name">equation</span><span class="operator">&gt;</span></code>.</li>
</ul>
</div>
</div>
</div>
</div>
</div></body>
</html>
